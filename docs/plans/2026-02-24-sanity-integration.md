# Sanity Integration Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace static `me/` files and hardcoded env var config with a Sanity CMS document so all profile content and site config can be updated through Sanity Studio without committing or redeploying.

**Architecture:** The backend fetches a single `profile` document from Sanity at startup, caches all fields on `Me`, and serves them via `/config.js`. The frontend reads config synchronously from `window.CAREER_CONFIG` as before — no client-side async fetch. A local file fallback remains for dev without Sanity.

**Tech Stack:** Sanity (free public dataset), Sanity Studio (hosted), Python `requests` (already in deps), Vitest (frontend tests), pytest (backend tests — already configured).

---

## Prerequisites (manual — do before Task 1)

1. Go to [sanity.io/manage](https://sanity.io/manage) → New Project → name it "career-conversation"
2. Choose "Production" dataset, Public visibility
3. Note your **Project ID** (shown in project settings)
4. Install Sanity CLI: `npm install -g sanity@latest`

---

### Task 1: Create Sanity schema

**Files:**
- Create: `sanity/schemas/profile.ts`
- Create: `sanity/schemas/index.ts`
- Create: `sanity/sanity.config.ts`
- Create: `sanity/package.json` (generated by CLI)

**Step 1: Scaffold Sanity Studio in `sanity/` subdirectory**

```bash
mkdir sanity && cd sanity
npm create sanity@latest -- --project <YOUR_PROJECT_ID> --dataset production --template clean --typescript
# When asked for output path: . (current directory)
```

**Step 2: Replace the generated schema index**

`sanity/schemas/index.ts`:
```typescript
import profile from './profile'
export const schemaTypes = [profile]
```

**Step 3: Create the profile schema**

`sanity/schemas/profile.ts`:
```typescript
export default {
  name: 'profile',
  title: 'Profile',
  type: 'document',
  fields: [
    { name: 'name',        title: 'Name',               type: 'string' },
    { name: 'title',       title: 'Title',              type: 'string' },
    { name: 'linkedinUrl', title: 'LinkedIn URL',        type: 'url'    },
    { name: 'websiteUrl',  title: 'Website URL',         type: 'url'    },
    {
      name: 'suggestions',
      title: 'Chat Suggestions',
      type: 'array',
      of: [{ type: 'string' }],
    },
    { name: 'summary',      title: 'Summary',            type: 'text' },
    { name: 'profilePdf',   title: 'Profile PDF',        type: 'file' },
    { name: 'referencePdf', title: 'Reference Letter PDF', type: 'file' },
  ],
}
```

**Step 4: Deploy Studio and add content**

```bash
cd sanity && npm run deploy
```

Open the deployed Studio URL, create one `profile` document with your scrubbed content, and upload PDFs.

**Step 5: Verify the Sanity API returns data**

```bash
curl "https://<PROJECT_ID>.api.sanity.io/v2021-06-07/data/query/production?query=*%5B_type+%3D%3D+%22profile%22%5D%5B0%5D%7Bname%2Ctitle%7D"
```

Expected: `{"ms":...,"query":"...","result":{"name":"Alex Rabinovich","title":"..."}}`

**Step 6: Commit**

```bash
git add sanity/
git commit -m "Add Sanity Studio schema for profile content"
```

---

### Task 2: Backend — Sanity fetch in `chat.py` (TDD)

**Files:**
- Modify: `tests/test_chat.py`
- Modify: `backend/chat.py`

**Step 1: Add failing tests for Sanity path**

Append to `tests/test_chat.py`:

```python
import os
from io import BytesIO


# ── Sanity fetch path ──────────────────────────────────────────

def _make_sanity_doc(**overrides):
    """Return a minimal valid Sanity profile doc."""
    doc = {
        "name": "Alex Rabinovich",
        "title": "Senior Engineer",
        "linkedinUrl": "https://linkedin.com/in/alex",
        "websiteUrl": "https://alexrabinovich.onrender.com/",
        "suggestions": ["Tell me about your background"],
        "summary": "Experienced software engineer",
        "profilePdfUrl": "https://cdn.sanity.io/files/proj/prod/profile.pdf",
        "referencePdfUrl": None,
    }
    doc.update(overrides)
    return doc


def _create_me_from_sanity(doc=None):
    """Create a Me instance using the Sanity path (SANITY_PROJECT_ID set)."""
    if doc is None:
        doc = _make_sanity_doc()

    api_response = MagicMock()
    api_response.json.return_value = {"result": doc}

    pdf_response = MagicMock()
    pdf_response.content = b"fake pdf bytes"

    mock_page = MagicMock()
    mock_page.extract_text.return_value = "Profile text"

    with patch.dict(os.environ, {"SANITY_PROJECT_ID": "testproject123"}), \
         patch("backend.chat.requests.get") as mock_get, \
         patch("backend.chat.PdfReader") as mock_reader, \
         patch("backend.chat.OpenAI"):
        mock_get.side_effect = [api_response, pdf_response]
        mock_reader.return_value.pages = [mock_page]
        me = Me()

    return me


def test_sanity_init_loads_name_and_title():
    me = _create_me_from_sanity()
    assert me.name == "Alex Rabinovich"
    assert me.title == "Senior Engineer"


def test_sanity_init_loads_urls():
    me = _create_me_from_sanity()
    assert me.linkedin_url == "https://linkedin.com/in/alex"
    assert me.website_url == "https://alexrabinovich.onrender.com/"


def test_sanity_init_loads_suggestions():
    me = _create_me_from_sanity()
    assert me.suggestions == ["Tell me about your background"]


def test_sanity_init_loads_summary():
    me = _create_me_from_sanity()
    assert me.summary == "Experienced software engineer"


def test_sanity_init_loads_profile_pdf():
    me = _create_me_from_sanity()
    assert me.profile == "Profile text"


def test_sanity_init_ref_letter_empty_when_url_null():
    doc = _make_sanity_doc(referencePdfUrl=None)
    me = _create_me_from_sanity(doc=doc)
    assert me.ref_letter == ""


def test_sanity_init_loads_ref_letter_when_url_present():
    doc = _make_sanity_doc(referencePdfUrl="https://cdn.sanity.io/files/proj/prod/ref.pdf")

    api_response = MagicMock()
    api_response.json.return_value = {"result": doc}

    profile_pdf = MagicMock()
    profile_pdf.content = b"profile pdf"

    ref_pdf = MagicMock()
    ref_pdf.content = b"ref pdf"

    call_count = 0

    def mock_pdf_reader(_):
        nonlocal call_count
        reader = MagicMock()
        page = MagicMock()
        page.extract_text.return_value = "Ref text" if call_count > 0 else "Profile text"
        reader.pages = [page]
        call_count += 1
        return reader

    with patch.dict(os.environ, {"SANITY_PROJECT_ID": "testproject123"}), \
         patch("backend.chat.requests.get") as mock_get, \
         patch("backend.chat.PdfReader", side_effect=mock_pdf_reader), \
         patch("backend.chat.OpenAI"):
        mock_get.side_effect = [api_response, profile_pdf, ref_pdf]
        me = Me()

    assert me.ref_letter == "Ref text"


def test_sanity_website_url_defaults_to_empty_when_absent():
    doc = _make_sanity_doc()
    doc.pop("websiteUrl", None)
    me = _create_me_from_sanity(doc=doc)
    assert me.website_url == ""


def test_sanity_suggestions_defaults_to_empty_list_when_absent():
    doc = _make_sanity_doc()
    doc.pop("suggestions", None)
    me = _create_me_from_sanity(doc=doc)
    assert me.suggestions == []


def test_local_fallback_used_when_no_sanity_project_id():
    """Without SANITY_PROJECT_ID, Me loads from local files."""
    me = _create_me()  # uses existing _create_me which has no SANITY_PROJECT_ID
    assert me.profile == "Profile text"
    assert me.name == "Alex Rabinovich"
```

**Step 2: Run tests to confirm they fail**

```bash
uv run pytest tests/test_chat.py -k "sanity" -v
```

Expected: all new `test_sanity_*` tests FAIL with `AttributeError` (no `title`, `linkedin_url`, etc. yet).

**Step 3: Rewrite `backend/chat.py`**

Replace the file with:

```python
import json
import os
from io import BytesIO

import openai
import requests
from openai import OpenAI
from pypdf import PdfReader

from backend.tools import push, record_user_details, record_unknown_question, tools

ME_DIR = os.environ.get("ME_DIR", "me")
_SANITY_API_VERSION = "2021-06-07"


class Me:
    def __init__(self) -> None:
        self.openai = OpenAI()
        project_id = os.environ.get("SANITY_PROJECT_ID")
        if project_id:
            self._load_from_sanity(project_id)
        else:
            self._load_from_files()

    def _load_from_sanity(self, project_id: str) -> None:
        dataset = os.environ.get("SANITY_DATASET", "production")
        query = (
            '*[_type == "profile"][0]{'
            'name, title, linkedinUrl, websiteUrl, suggestions, summary,'
            '"profilePdfUrl": profilePdf.asset->url,'
            '"referencePdfUrl": referencePdf.asset->url'
            "}"
        )
        url = f"https://{project_id}.api.sanity.io/v{_SANITY_API_VERSION}/data/query/{dataset}"
        response = requests.get(url, params={"query": query})
        response.raise_for_status()
        doc = response.json()["result"]

        self.name = doc["name"]
        self.title = doc["title"]
        self.linkedin_url = doc["linkedinUrl"]
        self.website_url = doc.get("websiteUrl") or ""
        self.suggestions = doc.get("suggestions") or []
        self.summary = doc["summary"]

        pdf_bytes = requests.get(doc["profilePdfUrl"]).content
        self.profile = "".join(
            p.extract_text() or "" for p in PdfReader(BytesIO(pdf_bytes)).pages
        )

        ref_url = doc.get("referencePdfUrl")
        if ref_url:
            ref_bytes = requests.get(ref_url).content
            self.ref_letter = "".join(
                p.extract_text() or "" for p in PdfReader(BytesIO(ref_bytes)).pages
            )
        else:
            self.ref_letter = ""

    def _load_from_files(self) -> None:
        self.name = "Alex Rabinovich"
        self.title = os.environ.get("OWNER_TITLE", "")
        self.linkedin_url = os.environ.get("LINKEDIN_URL", "")
        self.website_url = os.environ.get("WEBSITE_URL", "")
        self.suggestions = []

        reader = PdfReader(f"{ME_DIR}/profile.pdf")
        self.profile = "".join(p.extract_text() or "" for p in reader.pages)

        try:
            reader = PdfReader(f"{ME_DIR}/reference_letter.pdf")
            self.ref_letter = "".join(p.extract_text() or "" for p in reader.pages)
        except FileNotFoundError:
            self.ref_letter = ""

        with open(f"{ME_DIR}/summary.txt", "r", encoding="utf-8") as f:
            self.summary = f.read()

    def system_prompt(self) -> str:
        intro = (
            f"You are acting as {self.name}. "
            f"You are answering questions on {self.name}'s website, particularly questions related to "
            f"{self.name}'s career, background, skills and experience. "
            f"Your responsibility is to represent {self.name} for interactions on the website as faithfully as possible. "
            f"You are given a summary of {self.name}'s background and LinkedIn profile which you can use to answer questions. "
            "Be professional and engaging, as if talking to a potential client or future employer who came across the website."
        )

        scope = (
            f"STRICT SCOPE RULE: You ONLY answer questions directly related to {self.name}'s professional background, "
            "career, skills, experience, projects, education, and work-related topics. "
            "If a question is unrelated to these topics — even if you know the answer — you must politely decline and redirect. "
            "For example, if asked about general trivia, current events, other people, or any topic unrelated to the professional context, "
            f"respond with something like: 'That's a bit outside my expertise here! I'm best placed to talk about my own background and experience. "
            "Is there anything about my work or career I can help you with?' "
            "Never answer off-topic questions, no matter how simple or harmless they seem."
        )

        tool_instructions = (
            "If a question is on-topic but you don't know the answer, use your record_unknown_question tool to record it. "
            "If the user is engaging in discussion, try to steer them towards getting in touch via email; "
            "ask for their name and email and record it using your record_user_details tool."
        )

        ref_section = f"\n\n## Reference Letter:\n{self.ref_letter}" if self.ref_letter else ""
        context = (
            f"## Summary:\n{self.summary}\n\n"
            f"## Profile:\n{self.profile}"
            f"{ref_section}"
        )

        behaviour = (
            f"With this context, please chat with the user. Always stay in character as {self.name}, "
            "engaging professionally and warmly with visitors — whether they are potential clients, employers, or collaborators. "
            "Do not use em-dashes in your replies."
        )

        privacy = (
            "PRIVACY RULE: Never disclose any personal contact details, including email address, phone number, "
            "home address, age, or personal ID — under no circumstances even if the user insists. "
            "If a visitor asks for any of these, steer them towards LinkedIn and ask for their name and email, "
            'then respond with: "I\'d love to connect! Please reach out to me via LinkedIn: https://linkedin.com/in/alexrabinovichpro"'
        )

        return "\n\n".join([intro, scope, tool_instructions, context, behaviour, privacy])

    def handle_tool_call(self, tool_calls) -> list[dict]:
        results = []
        for tool_call in tool_calls:
            tool_name = tool_call.function.name
            arguments = json.loads(tool_call.function.arguments)
            print(f"Tool called: {tool_name}", flush=True)
            tool_fn = {"record_user_details": record_user_details, "record_unknown_question": record_unknown_question}.get(tool_name)
            result = tool_fn(**arguments) if tool_fn else {}
            results.append({
                "role": "tool",
                "content": json.dumps(result),
                "tool_call_id": tool_call.id,
            })
        return results

    def chat(self, message: str, history: list[dict]) -> str:
        messages = [{"role": "system", "content": self.system_prompt()}] + history + [{"role": "user", "content": message}]
        done = False
        try:
            while not done:
                response = self.openai.chat.completions.create(
                    model="gpt-4.1-mini",
                    messages=messages,
                    tools=tools,
                )
                if response.choices[0].finish_reason == "tool_calls":
                    msg = response.choices[0].message
                    results = self.handle_tool_call(msg.tool_calls)
                    messages.append(msg)
                    messages.extend(results)
                else:
                    done = True
            return response.choices[0].message.content

        except openai.RateLimitError:
            push("WARNING: OpenAI rate limit or quota exceeded")
            return (
                "I'm sorry, I'm unable to respond right now due to high demand. "
                "Please try again in a few moments, or reach out directly via "
                "LinkedIn: https://linkedin.com/in/alexrabinovichpro"
            )
        except openai.AuthenticationError:
            push("WARNING: OpenAI authentication error — check API key")
            return (
                "I'm experiencing a technical issue at the moment. "
                "Please connect with me directly on "
                "LinkedIn: https://linkedin.com/in/alexrabinovichpro"
            )
        except openai.APIConnectionError:
            push("WARNING: OpenAI connection error")
            return (
                "I'm having trouble connecting right now. "
                "Please try again shortly, or reach out via "
                "LinkedIn: https://linkedin.com/in/alexrabinovichpro"
            )
        except Exception as e:
            push(f"WARNING: Unexpected error in chat — {type(e).__name__}: {e}")
            print(f"Unexpected chat error: {e}", flush=True)
            return (
                "Something unexpected happened on my end. "
                "Please try again, or get in touch via "
                "LinkedIn: https://linkedin.com/in/alexrabinovichpro"
            )
```

**Step 4: Run all backend chat tests**

```bash
uv run pytest tests/test_chat.py -v
```

Expected: all tests PASS.

**Step 5: Commit**

```bash
git add backend/chat.py tests/test_chat.py
git commit -m "Fetch profile from Sanity at startup, fall back to local files"
```

---

### Task 3: Backend — `/config.js` endpoint (TDD)

**Files:**
- Modify: `tests/test_main.py`
- Modify: `backend/main.py`

**Step 1: Update the test fixture and config.js tests**

In `tests/test_main.py`, make these changes:

1. Update `client_with_me` fixture to set explicit string attrs on the mock:

```python
@pytest.fixture
def client_with_me():
    """TestClient with a mocked Me instance, lifespan triggered."""
    mock_me = MagicMock()
    mock_me.chat.return_value = "test reply"
    mock_me.name = ""
    mock_me.title = ""
    mock_me.linkedin_url = ""
    mock_me.website_url = ""
    mock_me.suggestions = []
    with patch.object(main_module, "Me", return_value=mock_me):
        with TestClient(app) as client:
            yield client, mock_me
```

2. Replace `test_config_js_includes_env_values` and `test_config_js_defaults_to_empty_strings` with:

```python
def test_config_js_includes_me_values(client_with_me):
    client, mock_me = client_with_me
    mock_me.name = "Alex Rabinovich"
    mock_me.title = "Software Engineer"
    mock_me.linkedin_url = "https://linkedin.com/in/alex"
    mock_me.website_url = "https://alexrabinovich.onrender.com/"
    mock_me.suggestions = ["What's your background?"]
    response = client.get("/config.js")
    json_str = response.text[len("window.CAREER_CONFIG = "):-1]
    config = json.loads(json_str)
    assert config["ownerName"] == "Alex Rabinovich"
    assert config["ownerTitle"] == "Software Engineer"
    assert config["linkedinUrl"] == "https://linkedin.com/in/alex"
    assert config["websiteUrl"] == "https://alexrabinovich.onrender.com/"
    assert config["suggestions"] == ["What's your background?"]


def test_config_js_defaults_to_empty_values(client_with_me):
    client, _ = client_with_me
    response = client.get("/config.js")
    json_str = response.text[len("window.CAREER_CONFIG = "):-1]
    config = json.loads(json_str)
    assert config == {
        "ownerName": "",
        "ownerTitle": "",
        "linkedinUrl": "",
        "websiteUrl": "",
        "suggestions": [],
    }
```

**Step 2: Run tests to confirm updated tests fail**

```bash
uv run pytest tests/test_main.py -v
```

Expected: `test_config_js_includes_me_values` and `test_config_js_defaults_to_empty_values` FAIL (endpoint still reads env vars).

**Step 3: Update `/config.js` in `backend/main.py`**

Replace the `config_js` function:

```python
@app.get("/config.js")
async def config_js():
    config = {
        "ownerName":   me.name,
        "ownerTitle":  me.title,
        "linkedinUrl": me.linkedin_url,
        "websiteUrl":  me.website_url,
        "suggestions": me.suggestions,
    }
    return Response(
        content=f"window.CAREER_CONFIG = {json.dumps(config)};",
        media_type="application/javascript",
    )
```

**Step 4: Run all backend tests**

```bash
uv run pytest tests/ -v
```

Expected: all tests PASS.

**Step 5: Commit**

```bash
git add backend/main.py tests/test_main.py
git commit -m "Serve config from Me instance, add websiteUrl and suggestions"
```

---

### Task 4: Frontend — dynamic config (TDD)

**Files:**
- Modify: `frontend/src/main.test.ts`
- Modify: `frontend/src/main.ts`

**Step 1: Update `DEFAULT_CONFIG` and add failing tests**

In `frontend/src/main.test.ts`:

1. Replace `DEFAULT_CONFIG`:

```typescript
const DEFAULT_CONFIG = {
  ownerName: 'Alex Rabinovich',
  ownerTitle: 'Software Engineer',
  linkedinUrl: 'https://linkedin.com/in/alex',
  websiteUrl: 'https://alexrabinovich.onrender.com/',
  suggestions: [
    "What's your technical background?",
    "Tell me about your management experience",
    "What industries have you worked in?",
    "Are you open to relocation?",
  ],
}
```

2. Update the existing `'renders 4 suggestion chips'` test:

```typescript
it('renders chips matching config suggestions', async () => {
  await setup()
  const chips = document.querySelectorAll('.suggestion-chip')
  expect(chips.length).toBe(DEFAULT_CONFIG.suggestions.length)
  expect((chips[0] as HTMLElement).dataset.prompt).toBe(DEFAULT_CONFIG.suggestions[0])
})
```

3. Add new tests at the end of the `initialization` describe block:

```typescript
it('renders website link in footer', async () => {
  await setup()
  const links = Array.from(document.querySelectorAll('.footer-link')) as HTMLAnchorElement[]
  const hrefs = links.map(l => l.getAttribute('href'))
  expect(hrefs).toContain('https://alexrabinovich.onrender.com/')
})

it('omits website link when websiteUrl is empty', async () => {
  await setup({ ...DEFAULT_CONFIG, websiteUrl: '' })
  const links = document.querySelectorAll('.footer-link')
  expect(links.length).toBe(1)
})

it('renders zero chips when suggestions is empty', async () => {
  await setup({ ...DEFAULT_CONFIG, suggestions: [] })
  const chips = document.querySelectorAll('.suggestion-chip')
  expect(chips.length).toBe(0)
})

it('chip prompt matches config suggestion text', async () => {
  await setup({ ...DEFAULT_CONFIG, suggestions: ['Tell me about Python'] })
  const chip = document.querySelector('.suggestion-chip') as HTMLElement
  expect(chip.dataset.prompt).toBe('Tell me about Python')
  expect(chip.textContent).toBe('Tell me about Python')
})
```

**Step 2: Run frontend tests to confirm failures**

```bash
cd frontend && npm test -- --reporter=verbose 2>&1 | head -60
```

Expected: new tests FAIL, `'renders chips matching config suggestions'` FAIL (chips still hardcoded).

**Step 3: Update `frontend/src/main.ts`**

Replace the config block at the top (lines 5–8):

```typescript
const _cfg = (window as any).CAREER_CONFIG ?? {};
const OWNER_NAME    = _cfg.ownerName   || '';
const OWNER_TITLE   = _cfg.ownerTitle  || '';
const LINKEDIN_URL  = _cfg.linkedinUrl || '#';
const WEBSITE_URL   = _cfg.websiteUrl  || '';
const SUGGESTIONS: string[] = Array.isArray(_cfg.suggestions) ? _cfg.suggestions : [];
```

Replace the hardcoded `SUGGESTIONS` array (remove the old `const SUGGESTIONS = [...]`).

Update the footer in `app.innerHTML`:

```typescript
  <!-- Footer -->
  <footer class="app-footer">
    Powered by AI · Responses may not capture every detail
    ${WEBSITE_URL ? `· <a href="${WEBSITE_URL}" target="_blank" rel="noopener noreferrer" class="footer-link">Website</a>` : ''}
    · <a href="${LINKEDIN_URL}" target="_blank" rel="noopener noreferrer" class="footer-link">Connect on LinkedIn</a> for direct contact
  </footer>
```

Update the suggestions section in `app.innerHTML`:

```typescript
  <!-- Suggestions -->
  <div id="suggestions" class="suggestions">
    ${SUGGESTIONS.map(s => `<button class="suggestion-chip" data-prompt="${s}">${s}</button>`).join('')}
  </div>
```

**Step 4: Run all frontend tests**

```bash
cd frontend && npm test
```

Expected: all tests PASS including the existing `'chip without data-prompt attribute'` test (still works — manually injected chip still has no `data-prompt`).

**Step 5: Run coverage**

```bash
cd frontend && npm run test:coverage
```

Expected: 100% coverage.

**Step 6: Commit**

```bash
git add frontend/src/main.ts frontend/src/main.test.ts
git commit -m "Read suggestions and websiteUrl from config, add website footer link"
```

---

### Task 5: Dockerfile and deployment config

**Files:**
- Modify: `Dockerfile`
- Modify: `render.yaml`
- Modify: `.env.example`

**Step 1: Update Dockerfile — remove `me/` copy**

In `Dockerfile`, delete the line:

```dockerfile
COPY me/ ./me/
```

The `me/` directory remains in the repo for local dev fallback. It is no longer needed in the production Docker image since the backend fetches from Sanity.

**Step 2: Update `render.yaml`**

Replace the three `VITE_*` env var entries with Sanity vars:

```yaml
services:
  - type: web
    name: career-conversation
    env: docker
    plan: free
    envVars:
      - key: OPENAI_API_KEY
        sync: false
      - key: PUSHOVER_TOKEN
        sync: false
      - key: PUSHOVER_USER
        sync: false
      - key: SANITY_PROJECT_ID
        sync: false
      - key: SANITY_DATASET
        value: production
```

**Step 3: Update `.env.example`**

```bash
# ── Required ───────────────────────────────────────────────────────────────────

# OpenAI API key — get yours at https://platform.openai.com/api-keys
OPENAI_API_KEY=

# ── Sanity CMS ─────────────────────────────────────────────────────────────────
# Project ID from sanity.io/manage — required in production
SANITY_PROJECT_ID=
# Dataset name (default: production)
SANITY_DATASET=production

# ── Optional — local dev fallback (used only when SANITY_PROJECT_ID is not set) ─
# These values are served by /config.js when running without Sanity
OWNER_TITLE=Your Title
LINKEDIN_URL=https://www.linkedin.com/in/yourprofile/
WEBSITE_URL=https://yoursite.example.com/

# ── Optional — Pushover notifications ──────────────────────────────────────────
PUSHOVER_TOKEN=
PUSHOVER_USER=
```

**Step 4: Build Docker image to verify it still builds**

```bash
docker build -t career-conversation-test .
```

Expected: build succeeds. If it fails because `me/` directory is missing in context, that's fine — the `COPY me/ ./me/` line is gone so it won't fail on that.

**Step 5: Commit**

```bash
git add Dockerfile render.yaml .env.example
git commit -m "Remove me/ from Docker image, swap VITE_* vars for SANITY_* in deploy config"
```

---

### Task 6: Docs

**Files:**
- Modify: `CLAUDE.md`
- Modify: `README.md`

**Step 1: Update `CLAUDE.md`**

In the **Environment Variables** section, replace:

```
Required: `OPENAI_API_KEY`, `VITE_LINKEDIN_URL`, `VITE_OWNER_NAME`, `VITE_OWNER_TITLE`
```

with:

```
Required: `OPENAI_API_KEY`, `SANITY_PROJECT_ID`
Optional: `SANITY_DATASET` (default `"production"`), `PUSHOVER_TOKEN`, `PUSHOVER_USER` (mobile notifications)
Local dev fallback (no Sanity): `OWNER_TITLE`, `LINKEDIN_URL`, `WEBSITE_URL`
```

In the **Architecture** section, add to the `backend/` block:

```
  chat.py    # Me class — fetches from Sanity at startup (falls back to me/ if SANITY_PROJECT_ID unset)
             # system_prompt() joins 6 sections: intro, scope, tool_instructions, context, behaviour, privacy
```

Replace the **Gotchas** bullet:
```
- `me/` is gitignored — must be created manually. Backend fails on init without `profile.pdf` and `summary.txt`. `reference_letter.pdf` is optional.
```
with:
```
- `me/` files are local dev fallback only — used when `SANITY_PROJECT_ID` is not set. Production always uses Sanity.
- In production (Render), set `SANITY_PROJECT_ID`. Without it the backend tries to read `me/` which is not in the Docker image.
```

Remove the line about `CORS is hardcoded` referencing `VITE_*` env vars (if present).

**Step 2: Update `README.md`**

Replace the **Local Setup — Required Files** section:

```markdown
## Local Setup

### 1. Set environment variables

```bash
cp .env.example .env
# Fill in OPENAI_API_KEY and SANITY_PROJECT_ID
# Optionally fill in PUSHOVER_TOKEN / PUSHOVER_USER
```

For local dev without Sanity, the backend falls back to reading from `me/`:
- `me/profile.pdf` and `me/summary.txt` must exist
- `me/reference_letter.pdf` is optional

### 2. Start everything

```bash
./start.sh
```
```

In the **Deploy to Render** section, replace step 3:

```markdown
3. Set the following in the Environment Variables section:
   - OPENAI_API_KEY — required
   - SANITY_PROJECT_ID — required (your Sanity project ID from sanity.io/manage)
   - SANITY_DATASET — optional, defaults to "production"
   - PUSHOVER_TOKEN, PUSHOVER_USER — optional, for mobile notifications
```

Add a new **Updating Content** section at the end:

```markdown
## Updating Content

All profile content and site config lives in Sanity Studio.

1. Open your Sanity Studio (deployed at `https://<project>.sanity.io/studio` or run `cd sanity && npm run dev` locally)
2. Edit the `Profile` document — update text fields, upload new PDFs, change suggestions
3. In the Render dashboard → your service → **Restart** (not Redeploy)

The service restarts in seconds and fetches the latest content from Sanity.
```

**Step 3: Run all tests one final time**

```bash
uv run pytest tests/ -v && cd frontend && npm test
```

Expected: all tests PASS.

**Step 4: Commit**

```bash
git add CLAUDE.md README.md
git commit -m "Update docs for Sanity integration"
```
